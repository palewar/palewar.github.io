<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cs193p | Swift Wala]]></title>
  <link href="http://swiftwala.com/blog/categories/cs193p/atom.xml" rel="self"/>
  <link href="http://swiftwala.com/"/>
  <updated>2015-05-21T14:42:30+05:30</updated>
  <id>http://swiftwala.com/</id>
  <author>
    <name><![CDATA[Sachin Palewar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Custom View Drawing]]></title>
    <link href="http://swiftwala.com/drawing"/>
    <updated>2015-02-25T10:18:29+05:30</updated>
    <id>http://swiftwala.com/drawing</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/smily.png" width="150" height="150"> Stanford&rsquo;s <a href="https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099">CS193P</a> iOS8 development Course in Swift is turning out to be a well rounded and very useful resource so far. If you haven&rsquo;t started yet, I urge you to <a href="/calculator">start</a> now. In Lecture 5, Paul Hegarty starts with Objective-C Compatibility, he then talks about Property Lists etc. and then moves to completely different topic of <code>UIView</code> for remaining lecture. He does that often, keeps mixing different topics in a single lecture. I actually find that approach interesting and refreshing.</p>

<!-- more -->


<p>
Paul starts explaining <code>UIView</code> and covers basics like View Hierarchy and initialization. Then he stresses that we must use <strong><code>CGFloat</code></strong> and not <code>Float</code> or <code>Double</code> when custom drawing our views. Other data structures we use with views are <code>CGPoint</code>, <code>CGSize</code> and <code>CGRect</code>. <strong>Upper-Left is considered as origin</strong> in view coordinate system, and not lower-left like in Cartesian system. Increasing Y means down the screen. <code>bounds</code> and <code>frame</code> are a bit confusing. We should always use <code>bounds</code> when drawing in a view, as <code>center</code> and <code>frame</code> actually belong to <code>superview</code> and can&rsquo;t be used directly. Please watch and re-watch this portion in the video to really wrap your head around these very important concepts.</p>

<p>We need to override <code>drawRect</code> inside our view to do custom drawing however we should <strong>never call <code>drawRect</code> directly in our code</strong> and should instead call <code>setNeedsDisplay</code>, which will lead to <code>drawRect</code> being called by system. To create a smily face we need 1 big circle for the face, 2 smaller circles for eyes and one curve for the mouth. Code to draw the big circle is like this:</p>

<pre><code class="swift">//@IBDesignable is not required, but it's used to render FaceView in Storyboard
//without compiling.
@IBDesignable class FaceView: UIView {

    //@IBInspectable is used to make these properties available in Attributes Inspector
    //while using Storyboard.
    @IBInspectable var scale: CGFloat = 0.90 { didSet { setNeedsDisplay() } }
    @IBInspectable var lineWidth: CGFloat = 3 { didSet { setNeedsDisplay() } }
    @IBInspectable var color: UIColor = UIColor.blueColor() { didSet { setNeedsDisplay() } }

    var faceCenter: CGPoint {
        return convertPoint(center, fromView: superview)
    }

    var faceRadius: CGFloat {
        return min(bounds.size.width, bounds.size.height) / 2 * scale
    }

    override func drawRect(rect: CGRect) {

        //Drawing Face
        let facePath = UIBezierPath(arcCenter: faceCenter, radius: faceRadius, startAngle: 0, endAngle: CGFloat(2 * M_PI), clockwise: true)
        facePath.lineWidth = lineWidth
        color.set()
        facePath.stroke()

    }
}
</code></pre>

<p>Full code for the smily face is available at <a href="https://github.com/palewar/Swift-Samples">Github</a>. I have basically copied the code from the lecture so it&rsquo;s not my code, but I guess Paul won&rsquo;t mind me sharing it with all of you. Do watch the Lecture 5 video from the course, if you don&rsquo;t understand anything.</p>

<p>Now let me share some of my thoughts about the course and Paul. Paul has been teaching iOS development for years now, but he talks about Swift, which is not even a year old with equal ease and confidence. In Lecture 6 he mentions about <code>@IBDesignable</code> and <code>@IBInspectable</code> very casually and briefly and you almost don&rsquo;t realise he is talking about 2 <a href="http://nshipster.com/ibinspectable-ibdesignable/">great new features</a> which were introduced recently with XCode 6.</p>

<p>At times lectures do appear too crammed up and difficult to follow. Thankfully I am watching these lectures over iTunes so I can command Paul to repeat himself whenever I wish. I also sometime take a break between the lecture and do some further reading to help with understanding of the concepts, at times I just pause the lecture and sleep over it and resume when I wake up. I don&rsquo;t fret over not understanding everything almost immediately and keep moving ahead with the belief that eventually everything will make sense :-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calculator in Swift]]></title>
    <link href="http://swiftwala.com/calculator"/>
    <updated>2015-02-16T16:27:51+05:30</updated>
    <id>http://swiftwala.com/calculator</id>
    <content type="html"><![CDATA[<p><img src="/images/stanford-ios8.png"> All new <a href="https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099">CS193P</a> started at Stanford sometime back. Great news is, that it&rsquo;s being taught in Swift. I have just finished listening first 2 lectures. I am quite impressed with <strong>Paul Hegarty</strong>. He starts the lecture with firing Xcode, talking about it and then beginning to code a Calculator app in Swift. <!-- more --> He explains concepts as and when needed while using them. Quite hands-on and practical approach I must say.</p>

<p>If you have some experience with programming and are well conversant with <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">OOPS</a> concepts, then the course should be really easy to follow for you. It&rsquo;s a free course and available via iTunes, so I think anybody who is beginning with iOS development or Swift should really go through it.</p>

<p>Paul explains basics of <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html">autolayout</a> in Lecture 1 and explains constraints in Lecture 2. However what stands out in Lecture 2 (last 20 mins) is his explanation of <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>, he does that like a rock-star and uses roads, arrows, radio transmission analogies to drive home his message.</p>

<p>There are reading assignments and programming assignments associated with lectures. I religiously read all the prescribed sections from the official <a href="https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0">Apple book</a> and actually did learn a few new things which I missed when I went through the book earlier. A couple of them are:</p>

<blockquote><p>Swift’s remainder operator can also operate on floating-point numbers: 8 % 2.5   // equals 0.5</p></blockquote>

<p>and</p>

<blockquote><p>We should Use ++i and &ndash;i in all cases instead of i++/i&ndash;, for expected behavior of modifying i and returning the result.</p></blockquote>

<p>Then I moved onto Programming Assignment and started coding the calculator. However I was not really comfortable with the <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">RFP</a> Calculator, Paul demoed in the class, so I decided to instead code simple, standard calculator. Here is my code for it:</p>

<pre><code class="swift">class ViewController: UIViewController {

    @IBOutlet weak var displayLabel: UILabel!

    var isFirstDigit = true
    var operand1: Double = 0
    var operation = "="

    var displayValue: Double {
        get {
            //notice use of ! twice in below line. If you get that, then you have truely understood optionals :-)
            return NSNumberFormatter().numberFromString(displayLabel.text!)!.doubleValue
        }
        set {
            // Notice how we are using a Property Setter to perform additional tasks while 
            //setting value for the property
            displayLabel.text = "\(newValue)"
            isFirstDigit = true
            operation = "="

        }
    }

    //This single IBAction function is tied to all the digit buttons
    @IBAction func appendDigit(sender: UIButton) {

        let digit = sender.currentTitle!
        //Notice use of ternery operator in below line which results in a single line code
        //instead of usual if-else multiple lines
        displayLabel.text = isFirstDigit ? digit : displayLabel.text! + digit
        isFirstDigit = false
    }

    @IBAction func clearDisplay(sender: AnyObject) {
        displayValue = 0
           }

    @IBAction func saveOperand(sender: UIButton) {
        operation = sender.currentTitle!
        operand1 = displayValue
        isFirstDigit = true
    }

    @IBAction func calculate(sender: AnyObject) {
        switch operation {
        case "÷":displayValue = operand1 / displayValue
        case "×":displayValue *= operand1
        case "+":displayValue += operand1
        case "−":displayValue = operand1 - displayValue
        default:break
        }
    }


}
</code></pre>

<p>It&rsquo;s pretty simple code and I hope should be clear enough. Full project code is available at <a href="https://github.com/palewar/Swift-Samples">Github</a></p>

<p>Happy Learning :-)</p>
]]></content>
  </entry>
  
</feed>
